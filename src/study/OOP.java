package study;

public class OOP {

    // 클래스와 객체


    // 객체 (object)
    // 지향 (oriented)
    // 프로그래밍 (programming)

    // 조립식 프로그래밍 > 프로그램을 부분부분 만들어놓고 전체를 완성하는 방법 (객체 조립)
    // ex) 자전거(프로그램) = 몸체(객체) + 바퀴(객체) + 핸들(객체)

    // OOP 장점 :
    // 1. 관리가 편함
    // 2. 객체를 재사용 할 수 있음
    // 3. 프로그램 확장이 편리해짐 (새로운 무언가를 추가하는게 쉬워짐)

    // 프로그램 > 객체의 조합으로 만듦

    // 객체는 클래스를 통해 만들 수 있음 (클래스 : 객체를 만들기 위한 설계도)
    // 객체는 클래스를 통해 만들 수 있음 (클래스 : 객체를 만들기 위한 설계도)
    // 객체는 클래스를 통해 만들 수 있음 (클래스 : 객체를 만들기 위한 설계도)
    // 객체를 만들기 위해선 각 객체 별 설계도인 클래스가 필요함.
    // 객체를 만들기 위해선 각 객체 별 설계도인 클래스가 필요함.

    // 객체의 또 다른 표현 : 인스턴스
    // 이 때 클래스를 통해 객체를 만들어야하는 과정 > 인스턴스화 (그래서 객체를 인스턴스화 라고 하기도 함)


    // 클래스 만들기
    // 클래스 구성요소 : 필드(Fields) , 메소드(Methods)
    // 필드 : 객체가 가지게 될 상태를 정의하는 것
    // 메소드 : 객체가 할 수 있는 동작을 기술


    // 고양이 클래스 설계
    // 필드(상태)
    // 이름, 품종, 체중

    // 메소드(동작)
    // 할퀴기(), 야옹()

    // 이걸 편하게 나타낸 표 = 클래스 다이어그램


// 3가지 : 클래스를 만든다 / 필드를 작성한다 / 메소드를 정의한다
//    class Cat {
//        // 필드 영역 (필드 스코프)
//        String name;
//        String breeds;
//        double weight;
//
//
//        // 메소드 영역 (메서드 스코프)
//        void claw() {
//            System.out.println("햘퀴기 !");
//        }
//
//        void meow() {
//            System.out.println("야옹 !!");
//        }
//
//    }

    // Dog dog1 = new Dog(); >> 객체 생성
    // dog1.name = "망고";    >> 필드 접근
    // dog1.bark();          >> 메서드 호출


    // 메소드의 public, static 키워드가 없음.
    // ㄴ> 객체 지향 파트에서는 해당 키워드를 사용하지 않음 ㅇㅅㅇ .. 왜징 ?




}
